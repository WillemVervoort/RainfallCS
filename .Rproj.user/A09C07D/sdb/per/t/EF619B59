{
    "contents" : "library(shiny)\nlibrary(RODBC)\n\n# here code that runs when app is launched\n# This is some old code just to get the BOM stations into a Rdata file\n# stations <- read.fwf(\"20140617_AllBOMstations.txt\", \n#                      widths=c(7,6,43,7,7,9,10,16,4,10,9,7),\n#                     skip = 3,\n#               na.strings = c(\"..\",\".....\",\"null\"))\n# colnames(stations) <-c(\"Site\",\"Dist\",\"Site_name\",\"Start\",\"End\",\"Lat\",\n#                        \"Lon\",\"Source\",\"STA\",\"Height_m\",\"Bar_ht\",\"WMO\")\n# save(stations, file=\"Stations.Rdata\")\n# this could be moved to a helper script\nload(\"stations.Rdata\")\n# Source the dataripper script to get the data from the BOM site\n# This is adaption of Jason Lessels' bomDailyDataripper\nsource(\"dataripper.r\")\n\n# This is the start of the server part\n# this gives the input and output\nshinyServer(function(input, output) {\n  \n  # here code that runs every time the app is visited\n\n  # create storage lists that are reactive\n  data <- reactiveValues()\n  name <- reactiveValues()\n  dates <- reactiveValues()\n# find the station in the \n  StationOut <- reactive({\n    # find the station name in the station data set, now includes finding the state\n      name$name <- stations[grep(input$Station,stations$Site_name,\n                                 ignore.case=T),c(\"Site\",\"Site_name\",\"STA\")]\n     # This selects at least a station in the right state, but what to do if I have more than 1 station?\n      name$name2 <- name$name[grep(input$state,name$name$STA),]\n    return(name$name2$Site)\n  })\n\n  output$choice <- renderUI({\n      selectInput('choice', label='Choose a Station',\n                  selected=StationOut()[1], StationOut())\n  })\n\nStationInput <- reactive({\n      if (input$goButton == 0) \n        return()\n      # use dataripper to download data from BOM station, now fudged to get 1 station\n      data <- bomDailyObs(input$choice,observation=input$type)\n      return(data)\n      })\n  \nDateInput <- reactive({\n   if (input$goButton == 0)  \n    return()\n   # this needs to read the dates and store them somewhere\n   begin <- input$dateRange[1]\n   end <- input$dateRange[2]\n   \n   if (begin >= min(StationInput()$Date)) {\n     dates$Startdate <- begin\n     dates$StartMsg <- paste(\"data analysis will start from\",begin)\n   } else {\n     dates$Startdate <- min(StationInput()$Date)\n     dates$StartMsg <- paste(\"the data only starts at\", min(StationInput()$Date))\n   }\n   \n   if (end <= max(StationInput()$Date)) {\n     dates$Enddate <- end\n     dates$EndMsg <- paste(\"and the data ends at\",end)\n   } else {\n     dates$Enddate <- max(StationInput()$Date)\n     dates$EndMsg <- paste(\"and the data only runs till\", max(StationInput()$Date))\n   }\n   return(dates)\n })  \n\n ####################################################################\n  # Now run the regression using lm and store the data into a database\n  # need to work out what database (huge? or just small)\n  # current thinking is: just make a database locally, move later\n  # Probably can use AERDM from the Uni and therefore use MySQL\n  \n  # ------------------------------------\n  # Start of output creation\n  #\n  # and create a plot\n output$plot <- renderPlot({\n    if (input$goButton == 0)\n      return() \n    # grab the data from StationInput\n    #data.plot <- StationInput()\n    # only run when submit is pushed??\n    # define labels\n    if (input$type==\"rain\") lab <- \"Rainfall\"; plot.t <- \"h\"\n    if (input$type==\"min_temp\") lab <- \"Minimum Temperature\"; plot.t <- \"l\"\n    if (input$type==\"max_temp\") lab <- \"Maximum Temperature\"; plot.t <- \"l\"\n    # make the plot\n    # define the begin and end rows to plot\n    temp <- match(DateInput()$Startdate,StationInput()$Date)\n    temp2 <- match(DateInput()$Enddate,StationInput()$Date)\n    \n    \n    # define the regression data frame\n    df <- data.frame(time=1:nrow(StationInput()[temp:temp2,]), \n                     response=StationInput()[temp:temp2,6])\n    # run the regression (start simple with just linear)\n    lm.mod <- lm(response~time,df)\n    switch(lm.mod, \"lm.mod\" = lm.mod)\n    \n    # predict the regression line\n    lm.line <- predict(lm.mod)\n    # make the plot\n    plot(StationInput()$Date[temp:temp2],\n         StationInput()[temp:temp2,6],\n         type=plot.t,col=\"blue\",\n         xlab= \"Date\", ylab=lab)\n    lines(StationInput()$Date[temp:temp2],lm.line)\n    })\n\noutput$dateMsg <- renderPrint({\n  if (input$goButton == 0)\n    return()\n  # Display the dates that are available or chosen\n  isolate(cat(DateInput()$StartMsg,DateInput()$EndMsg, \"\\n\"))\n})\n\n\n output$testoutput1 <- renderPrint({\n     if (input$goButton == 0)\n       return()\n     # this is just a test to see if everything works\n     summary(lm.mod)\n  })\n\n# Now need to run the regression and create the output\n# store output into a database\n  #output$testoutput1 <- renderText(paste(\"station selected =\",as.character(TypeInput)))\n  # on a second tab, extract the database info, summarise and plot\n  \n })\n",
    "created" : 1404204387259.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4290087673",
    "id" : "EF619B59",
    "lastKnownWriteTime" : 1405773410,
    "path" : "~/GitHub/RainfallCS/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}