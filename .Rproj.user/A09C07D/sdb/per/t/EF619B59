{
    "contents" : "library(shiny)\nlibrary(RODBC)\n\n# connect to data source\ndb <- odbcConnect(\"testwillem\", uid=\"rver4657\", pwd=\"7564revrMySQL\")\n\n# # testing ODBC\n# # find the names of the available tables\n# sqlTables(db)\n# \n# load the different tables into a data fram\ndf_main <- sqlQuery(db, \"select * from main_table\")\ndf_regr_results <- sqlQuery(db, \"select * from regr_results\")\ndf_regr_stats <- sqlQuery(db, \"select * from regr_stats\")\n\n# here code that runs when app is launched\n# This is some old code just to get the BOM stations into a Rdata file\n# stations <- read.fwf(\"20140617_AllBOMstations.txt\", \n#                      widths=c(7,6,43,7,7,9,10,16,4,10,9,7),\n#                     skip = 3,\n#               na.strings = c(\"..\",\".....\",\"null\"))\n# colnames(stations) <-c(\"Site\",\"Dist\",\"Site_name\",\"Start\",\"End\",\"Lat\",\n#                        \"Lon\",\"Source\",\"STA\",\"Height_m\",\"Bar_ht\",\"WMO\")\n# save(stations, file=\"Stations.Rdata\")\n# this could be moved to a helper script\nload(\"stations.Rdata\")\n# Source the dataripper script to get the data from the BOM site\n# This is adaption of Jason Lessels' bomDailyDataripper\nsource(\"dataripper.r\")\n\nplot.fun <- function(Dates = DateInput(),\n                     Data=StationInput(),\n                     d.type=input$type) {\n  \n  # define labels\n  if (d.type==\"rain\") lab <- \"Rainfall\"; plot.t <- \"h\"\n  if (d.type==\"min_temp\") lab <- \"Minimum Temperature\"; plot.t <- \"l\"\n  if (d.type==\"max_temp\") lab <- \"Maximum Temperature\"; plot.t <- \"l\"\n  \n  # find begin and end dates from info\n  time1 <- match(Dates$Startdate,Data$Date)\n  time2 <- match(Dates$Enddate,Data$Date)\n  \n  \n  # make the plot\n  plot(Data$Date[time1:time2],\n       Data[time1:time2,6],\n       type=plot.t,col=\"blue\",\n       xlab= \"Date\", ylab=lab)\n  lines(Data$Date[time1:time2],Dates$lm.line, col=\"red\",lty=2,lwd=3)\n}\n# This is the start of the server part\n# this gives the input and output\nshinyServer(function(input, output, session) {\n  \n  # here code that runs every time the app is visited\n\n  # create storage lists that are reactive\n  data <- reactiveValues()\n  name <- reactiveValues()\n  dates <- reactiveValues()\n# find the station in the \n  StationOut <- reactive({\n    # find the station name in the station data set, now includes finding the state\n      name$name <- stations[grep(input$Station,stations$Site_name,\n                                 ignore.case=T),c(\"Site\",\"Site_name\",\"STA\")]\n     # This selects at least a station in the right state, but what to do if I have more than 1 station?\n      name$name2 <- name$name[grep(input$state,name$name$STA),]\n   # return(name$name2$Site)\n  })\n\n  output$choice <- renderUI({\n      selectInput('choice', label='Choose a Station',\n                  selected=StationOut()[1], StationOut())\n  })\n\nStationInput <- reactive({\n      if (input$goButton == 0) \n        return()\n      # use dataripper to download data from BOM station, now fudged to get 1 station\n      data <- bomDailyObs(input$choice,observation=input$type)\n      return(data)\n      })\n  \nDateInput <- reactive({\n   if (input$goButton == 0)  \n    return()\n   # this needs to read the dates and store them somewhere\n   begin <- input$dateRange[1]\n   end <- input$dateRange[2]\n   isolate(\n   if (begin >= min(StationInput()$Date)) {\n     dates$Startdate <- begin\n     dates$StartMsg <- paste(\"data analysis will start from\",begin)\n   } else {\n     dates$Startdate <- min(StationInput()$Date)\n     dates$StartMsg <- paste(\"the data only starts at\", min(StationInput()$Date))\n   })\n   \n   isolate(\n   if (end <= max(StationInput()$Date)) {\n     dates$Enddate <- end\n     dates$EndMsg <- paste(\"and the data ends at\",end)\n   } else {\n     dates$Enddate <- max(StationInput()$Date)\n     dates$EndMsg <- paste(\"and the data only runs till\", max(StationInput()$Date))\n   })\n   # define the begin and end rows to plot\n   temp <- match(dates$Startdate,StationInput()$Date)\n   temp2 <- match(dates$Enddate,StationInput()$Date)\n   \n   \n   # define the regression data frame\n   df <- data.frame(time=1:nrow(StationInput()[temp:temp2,]), \n                    response=StationInput()[temp:temp2,6])\n   # run the regression (start simple with just linear)\n   lm.mod <- lm(response~time,df)\n   \n   # insert results into tables from database\n   splitTime <- strsplit(as.character(Sys.time()),\" \")\n   df_main[(nrow(df_main)+1),] <- c(input$choice,splitTime[[1]][1],splitTime[[1]][2],\n                    dates$Startdate,dates$Enddate,\"testing\")\n   \n   #bad <-   \n   # predict the regression line\n   lm.line <- predict(lm.mod,\n            new.data=data.frame(time=1:nrow(StationInput()[temp:temp2,]),\n                                          response=rep(0,nrow(df))))\n  # dates$lm.line <- NA\n   dates$lm.line[as.numeric(names(lm.line))] <- lm.line\n   dates$lm.mod <- lm.mod\n  # in here we need to write the output of the regression to the database\n  \n  \n   return(dates)\n })  \n\n ####################################################################\n  # Now run the regression using lm and store the data into a database\n  # need to work out what database (huge? or just small)\n  # current thinking is: just make a database locally, move later\n  # Probably can use AERDM from the Uni and therefore use MySQL\n  \n  # ------------------------------------\n  # Start of output creation\n  #\n  # and create a plot\n output$plot <- renderPlot({\n    if (input$goButton == 0)\n      return() \n    # grab the data from StationInput\n    #data.plot <- StationInput()\n    # only run when submit is pushed??\n    \n    plot.fun(Dates=DateInput(),\n                     Data=StationInput(),\n                     d.type=input$type)\n\n    })\n\n\noutput$dateMsg <- renderPrint({\n  if (input$goButton == 0)\n    return()\n  # Display the dates that are available or chosen\n  isolate(cat(DateInput()$StartMsg,DateInput()$EndMsg, \"\\n\"))\n})\n\noutput$slope <- renderPrint({\n  if (input$goButton == 0) return(\"\")\n  cat(\"The slope of the regression line is\",coef(DateInput()$lm.mod)[2],\n        \" with a p-value of\",summary(DateInput()$lm.mod)$coefficients[2,4],\".\")\n  cat(ifelse(summary(DateInput()$lm.mod)$coefficients[2,4]>0.05,\n         \" Statistically this means there is more than a 5% chance that this slope is similar to 0, \n         or we are not confident there is actually a trend.\",\n         paste(\" Statistically this means there is less than a 5% chance that this slope is similar to 0, \n         meaning we are quite confident there is a\",\n         ifelse(coef(DateInput()$lm.mod)[2]>=0,\"positive\",\"negative\"),\n         \"trend.\")))\n})\n\noutput$fitResults <- renderPrint({\n  if (input$goButton == 0) return(\"\")\n  cat(\"The adj. r_squared of the line fit is\",summary(DateInput()$lm.mod)$adj.r.squared,\n      \" with an average residual value (RMSE) of\",summary(DateInput()$lm.mod)$sigma,\n      ifelse(input$type==\"rain\",\"mm\",\"degrees C\"),\".\"\n      ,\" In general terms, the closer the adj. r-squared is to 1 means a better fit of the model to the data.\")\n})\n\noutput$CautionComment <- renderPrint({\n  if (input$goButton == 0) return(\"\")\n  cat(\"This analysis makes several assumptions, the most important one: that the trend in the data is linear! \n      Also, we are analysing the real data here, more common is to analyse the anomalies\")\n})\n\n\n  output$testoutput1 <- renderPrint({\n     if (input$goButton == 0) \"\"\n      # this is just a test to see if everything works\n            input$choice\n   })\n\non.exit(odbcClose(db))\n#  session$onSessionEnded(function() { \n   # q(\"no\") \n#    odbcClose(db)\n#  })\n\n })\n\n# write tables back to database\n\n# close the connection\n#\n",
    "created" : 1404204387259.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1988621715",
    "id" : "EF619B59",
    "lastKnownWriteTime" : 1407412514,
    "path" : "~/GitHub/RainfallCS/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}