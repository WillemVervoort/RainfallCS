{
    "contents" : "library(shiny)\nlibrary(RODBC)\nlibrary(oz)\n# for fancier plotting\nlibrary(ggplot2)\n\n# read in ozdata\noz.map <- read.csv(\"ozdata.csv\")\n\n# # connect to data source\n# db <- odbcConnect(\"testwillem\", uid=\"rver4657\", pwd=\"7564revrMySQL\")\n# \n# # # testing ODBC\n# # # find the names of the available tables\n# sqlTables(db)\n# #\n## Drop the different tables\n# sqlDrop(db,\"main_table\")\n# sqlDrop(db,\"regr_results\")\n# sqlDrop(db,\"regr_stats\")\n# odbcClose(db)\n\n## Clear the different tables\n#  sqlClear(db,\"main_table\")\n#  sqlClear(db,\"regr_results\")\n#  sqlClear(db,\"regr_stats\")\n#  odbcClose(db)\n\n# # load the different tables into a data frame\n# df_main <- sqlQuery(db, \"select * from main_table\",as.is = c(1,2,6,7),\n#                     stringsAsFactors=F)\n# df_regr_results <- sqlQuery(db, \"select * from regr_results\")\n# df_regr_stats <- sqlQuery(db, \"select * from regr_stats\")\n\n# here code that runs when app is launched\n# This is some old code just to get the BOM stations into a Rdata file\n# stations <- read.fwf(\"20140617_AllBOMstations.txt\", \n#                      widths=c(7,6,43,7,7,9,10,16,4,10,9,7),\n#                     skip = 3,\n#               na.strings = c(\"..\",\".....\",\"null\"))\n# colnames(stations) <-c(\"Site\",\"Dist\",\"Site_name\",\"Start\",\"End\",\"Lat\",\n#                        \"Lon\",\"Source\",\"STA\",\"Height_m\",\"Bar_ht\",\"WMO\")\n# save(stations, file=\"Stations.Rdata\")\n# this could be moved to a helper script\nload(\"stations.Rdata\")\n# Source the dataripper script to get the data from the BOM site\n# This is adaption of Jason Lessels' bomDailyDataripper\nsource(\"dataripper.r\")\n# # this is using the multiplot function from the R cookbook\n# source(\"multiplot.r\")\n\nplot.fun <- function(Dates = DateInput(),\n                     Data=StationInput(),\n                     d.type=input$type) {\n  \n  # define labels\n  if (d.type==\"rain\") lab <- \"Rainfall\"; plot.t <- \"h\"\n  if (d.type==\"min_temp\") lab <- \"Minimum Temperature\"; plot.t <- \"l\"\n  if (d.type==\"max_temp\") lab <- \"Maximum Temperature\"; plot.t <- \"l\"\n  \n  # find begin and end dates from info\n  time1 <- match(as.Date(Dates$Startdate),as.Date(Data$Date))\n  time2 <- match(as.Date(Dates$Enddate),as.Date(Data$Date))\n\n  plot.df <- data.frame(Dates=Data$Date[time1:time2],\n                        values=Data[time1:time2,6])\n  # make the plot\nt.plot <-  ggplot(plot.df,aes(x=Dates,y=values)) +\n         geom_line(colour=\"blue\") +\n        geom_smooth(method=\"lm\", formula=y~x, colour=\"red\",\n                                       linetype=2, size=2) +\n  xlab(\"Dates\") + ylab(lab) + \n  ggtitle(paste(Data$stationNumber[1], \"for\", as.Date(Dates$Startdate), \"to\",\n                as.Date(Dates$Enddate)))\n#         geom_line(x = Data$Date[time1:time2],Dates$lm.line, colour=\"blue\",\n#                   linetype=2, size=2)\nprint(t.plot)\n#   plot(Data$Date[time1:time2],\n#        Data[time1:time2,6],\n#        type=plot.t,col=\"blue\",\n#        xlab= \"Date\", ylab=lab)\n#   lines(Data$Date[time1:time2],Dates$lm.line, col=\"red\",lty=2,lwd=3)\n}\n\nhist.fun <- function(dat, type=\"rain\") {\n#    plot(dat$slope)\n#     plot.df <- dat\n  if (nrow(dat > 5)) {\n\n    dr <- dat[dat$data_type==\"rain\",]\n    if (nrow(dr) > 0 & type==\"rain\" ) {\n       hist(dr$slope, plot=T, xlab =\"Rainfall slope (mm/day) with p-value < 0.05\", \n            ylab = \"fraction of rainfall analyses\",\n            main=\"slopes of Rainfall\")  \n    }\n    dmt <- dat[dat$data_type==\"max_temp\",]\n    if (nrow(dmt) > 0 & type==\"max_temp\" ) {\n      hist(dmt$slope, xlab =\"Max T slope (deg C/day) with p-value < 0.05\", \n           ylab = \"fraction of all max T analyses\",\n           main=\"slopes of Maximum Temperature\"))  \n    }\n    dmit <- dat[dat$data_type==\"min_temp\",]\n    if (nrow(dmit) > 0 & type==\"min_temp\") {\n      hist(dmit$slope, plot=T , xlab =\"Min T slope (deg C/day) with p-value < 0.05\", \n           ylab = \"fraction of all min T analyses\",\n           main=\"slopes of Minimum Temperature\"))  \n    }\n    #    p1 <- ggplot(dat, aes(x=dat$slope)) +\n#        geom_histogram() +\n#      xlab(\"significant slopes with p-value < 0.05\") +\n#      ylab(\"slope or trend value\")\n#   p1\n#   dr <- dat[dat$data_type==\"rain\",]\n#   if (nrow(dr) > 0 ) {\n#     p2 <- ggplot(dr, aes(x=dr$slope)) +\n#       geom_histogram() +\n#       xlab(\"significant slopes with p-value < 0.05\") +\n#       ylab(\"Rainfall slope (mm/day)\")\n#   }\n#   dmt <- dat[dat$data_type==\"max_temp\",]\n#   if(nrow(dmt) > 0) {\n#     p3 <- ggplot(dmt, aes(x=dmt$slope)) +\n#       geom_histogram() +\n#       xlab(\"significant slopes with p-value < 0.05\") +\n#       ylab(\"Max Temperature slope (degrees C/day)\")\n#   }\n#   dmit <- dat[dat$data_type==\"min_temp\",]\n#   if (nrow(dmit)>0) {\n#     p4 <- ggplot(dmit, aes(x=dmit$slope)) +\n#       geom_histogram() +\n#       xlab(\"significant slopes with p-value < 0.05\") +\n#       ylab(\"Min Temperature slope (degrees C/day)\")\n#  }\n#   if (exists(\"p2\") & exists(\"p3\") & exists(\"p4\")) multiplot(p1,p2,p3,p4)\n#   if (exists(\"p2\") & exists(\"p3\") & !exists(\"p4\")) multiplot(p1,p2,p3)\n#   if (exists(\"p2\") & !exists(\"p4\") & !exists(\"p3\")) multiplot(p1,p2)\n#   if (!exists(\"p4\") & !exists(\"p3\") & !exists(\"p2\")) p1\n#   if (!exists(\"p2\") & exists(\"p3\") & exists(\"p4\")) multiplot(p1,p3,p4)\n#   if (!exists(\"p3\") & exists(\"p2\") & exists(\"p4\")) multiplot(p1,p2,p4)\n  }\n}\n\n# This is the start of the server part\n# this gives the input and output\nshinyServer(function(input, output, session) {\n  \n  # here code that runs every time the app is visited\n\n  # create storage lists that are reactive\n  data <- reactiveValues()\n  name <- reactiveValues()\n  dates <- reactiveValues()\n#  dat <- reactiveValues()\n# find the station in the \n  StationOut <- reactive({\n    # find the station name in the station data set, now includes finding the state\n      name$name <- stations[grep(input$Station,stations$Site_name,\n                                 ignore.case=T),c(\"Site\",\"Site_name\",\"STA\",\"Lat\",\"Lon\")]\n     # This selects at least a station in the right state, but what to do if I have more than 1 station?\n      name$name2 <- name$name[grep(input$state,name$name$STA),]\n   # return(name$name2$Site)\n  })\n\n  output$choice <- renderUI({\n      selectInput('choice', label='Choose a Station',\n                  selected=StationOut()$Site[1], StationOut()$Site)\n  })\n\nStationInput <- reactive({\n      if (input$goButton == 0) \n        return()\n      # use dataripper to download data from BOM station\n      isolate(\n             data <- bomDailyObs(input$choice,observation=input$type))\n             \n       return(data)\n      })\n  \nDateInput <- reactive({\n   if (input$goButton == 0)  \n    return()\n   # this needs to read the dates and store them somewhere\n   begin <- input$dateRange[1]\n   end <- input$dateRange[2]\n   isolate(\n   if (is.character(StationInput())==T) {stop(\"no data available\")})\n   isolate(\n   if (begin >= min(StationInput()$Date)) {\n     dates$Startdate <- begin\n     dates$StartMsg <- paste(\"data analysis will start from\",begin)\n   } else {\n     dates$Startdate <- min(StationInput()$Date) #data$Date)\n     dates$StartMsg <- paste(\"the data only starts at\", min(StationInput()$Date))\n   })\n   \n   isolate({\n   if (end <= max(StationInput()$Date)) {\n     dates$Enddate <- end\n     dates$EndMsg <- paste(\"and the data ends at\",end)\n   } else {\n     dates$Enddate <- max(StationInput()$Date) #max(data$Date)\n     dates$EndMsg <- paste(\"and the data only runs till\", max(StationInput()$Date))\n   }\n   # define the begin and end rows to plot\n   temp <- match(as.Date(dates$Startdate),as.Date(StationInput()$Date))\n   temp2 <- match(as.Date(dates$Enddate),as.Date(StationInput()$Date))\n\n   ####################################################################\n   # Now run the regression using lm and store the data into a database\n   # need to work out what database (huge? or just small)\n   # current thinking is: just make a database locally, move later\n   # Probably can use AERDM from the Uni and therefore use MySQL\n   \n   \n   # define the regression data frame\n   df <- data.frame(time=1:nrow(StationInput()[temp:temp2,]), \n                    response=StationInput()[temp:temp2,6])\n   # run the regression (start simple with just linear)\n   lm.mod <- lm(response~time,df)\n   \n   # insert results into tables from database\n   #splitTime <- strsplit(as.character(Sys.time()),\" \")\n   #df_main[(nrow(df_main)+1),] <- \n   \n   # Find latitude and longitude for each station\n   Lat <- as.numeric(as.character(StationOut()$Lat[grep(input$choice,StationOut()$Site)]))\n   Lon <- as.numeric(as.character(StationOut()$Lon[grep(input$choice,StationOut()$Site)]))\n   \n   # Create input line for database  \n   test <- data.frame(station_ID = as.character(input$choice),\n                      Lat = Lat,\n                      Lon = Lon,\n                      data_type = input$type,\n                      timestamp = as.character(Sys.time()),\n                      start_date = as.character(dates$Startdate),\n                      end_date = as.character(dates$Enddate),\n                      comment = \"testing\",stringsAsFactors=F)\n#    main_table$station_ID = \n#    main_table$Lat = Lat;  line$Lon = Lon\n#    main_table$data_type = as.character(input$type)\n#    main_table$comment = as.character(\"testing\")\n#    # append database\n   db <- odbcConnect(\"testwillem\", uid=\"rver4657\", pwd=\"7564revrMySQL\", case=\"nochange\")\n  sqlSave(db,test,tablename=\"main_table\",\n          rownames=F,append=T)\n   \n   # sqlQuery(db,\"DESCRIBE main_table\")\n#   odbcClose(db)\n#    # coefficients and stats\n    mod.res <-  summary(lm.mod)$coefficients   \n    results <- data.frame(station_ID = as.character(input$choice),intercept = mod.res[1,1],\n            se_int = mod.res[1,2], p_value_int = mod.res[1,4],\n            slope = mod.res[2,1], se_slope = mod.res[2,2],\n            p_value_slope = mod.res[2,4], data_type=input$type,\n            comment=\"test\", stringsAsFactors=F)\n  # append database\n  try(sqlSave(db, results, tablename=\"regr_results\", \n            rownames=FALSE, append=T))\n# model statistics and summary\n    mod.sum <- summary(lm.mod)\n    fstat<-mod.sum$fstatistic\n    pv <-   pf(fstat[1], fstat[2], fstat[3], lower.tail=FALSE) \n    bias <- sum(residuals(lm.mod),na.rm=T)\n    stats <- data.frame(station_ID = as.character(input$choice), rmse = mod.sum$sigma, \n                      r_sq = mod.sum$adj.r.squared, p_value = pv, \n                      bias = bias, stat1 = mod.sum$r.squared, \n                      stat2 = fstat[1], stat3 = fstat[2], \n                      stat4 = fstat[3], stat5 = -9999, data_type=input$type,\n                      comment = \"test\", stringsAsFactors=F)\n    # append database\n    try(sqlSave(db, stats, tablename=\"regr_stats\", \n            rownames=FALSE, append=T))\n    \n    #bad <-   \n   # predict the regression line\n#    lm.line <- predict(lm.mod,\n#             new.data=data.frame(time=1:nrow(StationInput()[temp:temp2,]),\n#                                           response=rep(0,nrow(df))))\n#    dates$lm.line <- vector(length=nrow(df))\n#    dates$lm.line[as.numeric(names(lm.line))] <- lm.line\n   dates$lm.mod <- lm.mod\n    }) # close isolate()\n   # in here we need to write the output of the regression to the database\n   return(dates)\n })  \n\n\n  # ------------------------------------\n  # Start of output creation\n  #\n  # and create a plot\n output$plot <- renderPlot({\n    if (input$goButton == 0)\n      return() \n    # grab the data from StationInput\n    #data.plot <- StationInput()\n    # only run when submit is pushed??\n    isolate(plot.fun(Dates=DateInput(),\n                     Data=StationInput(),\n                     d.type=input$type)\n    )\n    \n    })\n\nextractData <- reactive({\n  if (input$goButton == 0)\n    return() \n    db <- odbcConnect(\"testwillem\", uid=\"rver4657\", pwd=\"7564revrMySQL\")\n    test <- sqlQuery(db,paste(\"SELECT station_ID, slope, p_value_slope, data_type FROM regr_results\"))\n  #    hist(dat$slope)\n    test <- test[test$p_value_slope < 0.05,]\n   st <- sqlQuery(db,paste(\"SELECT station_ID, lat, lon FROM main_table\"))\n  #    hist(dat$slope)\n  # close data base\n  odbcClose(db)\n  # select only significant slopes\n  test <- test[test$p_value_slope < 0.05,]\n  st.out <- cbind(st[st$station_ID %in% test$station_ID,],test[,2:4])\n  neg.slope <- test[test$slope < 0,]\n  st.neg <- cbind(st[st$station_ID %in% neg.slope$station_ID,],neg.slope[,2:4])\n  pos.slope <- test[test$slope > 0,]\n  st.neg <- cbind(st[st$station_ID %in% pos.slope$station_ID,],pos.slope[,2:4])\n  return(list(stations = st, sig.st = st.out, neg.st = st.neg, pos.st = st.pos))\n})\n\n\noutput$rain_histogram <- renderPlot({\n  if (input$goButton == 0)\n    return() \n # updateTabsetPanel(session, selected=\"summary\")\n  hist.fun(dat=as.data.frame(extractData()$sig.st), type=\"rain\")\n  # plot the histograms\n  #isolate(hist.fun(dat = as.data.frame(extractData())))\n})\n\noutput$maxT_histogram <- renderPlot({\n  if (input$goButton == 0)\n    return() \n  # updateTabsetPanel(session, selected=\"summary\")\n  hist.fun(dat=as.data.frame(extractData()$sig.st), type=\"max_temp\")\n  # plot the histograms\n  #isolate(hist.fun(dat = as.data.frame(extractData())))\n})\n\noutput$minT_histogram <- renderPlot({\n  if (input$goButton == 0)\n    return() \n  # updateTabsetPanel(session, selected=\"summary\")\n  hist.fun(dat=as.data.frame(extractData()$sig.st), type=\"min_temp\")\n  # plot the histograms\n  #isolate(hist.fun(dat = as.data.frame(extractData())))\n})\n\n# Make the map of Australia with analysed data\noutput$rain_map <- renderPlot({\n  if (input$goButton == 0)\n    return() \n  # \n  # only run when submit is pushed??\n    isolate({ \n    p <- ggplot(subset(oz.map, border==\"coast\"), aes(long, lat))\n    p <- p + geom_path()\n    p <- p + coord_equal()\n    p <- p + ggtitle(\"Australia\")\n#    p\n#    p1 <- p +  geom_polygon(data=subset(oz.map,border=\"coast\"), aes(fill=state))\n    p <- p + geom_point(data=as.data.frame(extractData()$st)[,data_type==\"rain\"],\n                     aes(x=lon,y=lat),colour=\"black\",size=3)\n    p <- p + geom_point(data=as.data.frame(extractData()$neg.st)[,data_type==\"rain\"],\n                      aes(x=lon,y=lat),colour=\"red\",size=4)\n    p <- p + geom_point(data=as.data.frame(extractData()$pos.st)[,data_type==\"rain\"],\n                         aes(x=lon,y=lat),colour=\"blue\",size=4)\n    print(p)\n    })\n})\n\n# Make a map of Australia with pos and neg slopes\noutput$maxT_map <- renderPlot({\n  if (input$goButton == 0)\n    return() \n  # \n  # only run when submit is pushed??\n  \n  p <- ggplot(subset(oz.map, border==\"coast\"), aes(long, lat))\n  p <- p + geom_path()\n  p <- p + coord_equal()\n  p <- p + ggtitle(\"Australia\")\n  #    p1 <- p +  geom_polygon(data=subset(oz.map,border=\"coast\"), aes(fill=state))\n  p <- p + geom_point(data=as.data.frame(extractData()$st)[,data_type==\"max_temp\"],\n                       aes(x=lon,y=lat),colour=\"black\",size=3)\n  p <- p + geom_point(data=as.data.frame(extractData()$neg.st)[,data_type==\"max_temp\"],\n                       aes(x=lon,y=lat),colour=\"red\",size=4)\n  p <- p + geom_point(data=as.data.frame(extractData()$pos.st)[,data_type==\"max_temp\"],\n                        aes(x=lon,y=lat),colour=\"blue\",size=4)\n  print(p)\n})\n\noutput$minT_map <- renderPlot({\n  if (input$goButton == 0)\n    return() \n  # \n  # only run when submit is pushed??\n  isolate({\n  p <- ggplot(subset(oz.map, border==\"coast\"), aes(long, lat))\n  p <- p + geom_path()\n  p <- p + coord_equal()\n  p <- p + ggtitle(\"Australia\")\n  #    p1 <- p +  geom_polygon(data=subset(oz.map,border=\"coast\"), aes(fill=state))\n  p <- p + geom_point(data=as.data.frame(extractData()$st)[,data_type==\"min_temp\"],\n                       aes(x=lon,y=lat),colour=\"black\",size=3)\n  p <- p + geom_point(data=as.data.frame(extractData()$neg.st)[,data_type==\"min_temp\"],\n                        aes(x=lon,y=lat),colour=\"red\",size=4)\n  p <- p + geom_point(data=as.data.frame(extractData()$pos.st)[,data_type==\"min_temp\"],\n                        aes(x=lon,y=lat),colour=\"blue\",size=4)\n  print(p)\n  })\n})\n\n\noutput$dateMsg <- renderPrint({\n  if (input$goButton == 0)\n    return()\n  # Display the dates that are available or chosen\n  isolate(cat(DateInput()$StartMsg,DateInput()$EndMsg, \"\\n\"))\n})\n\noutput$slope <- renderPrint({\n  if (input$goButton == 0) return(\"\")\n  isolate({\n  cat(\"The slope of the regression line is\",coef(DateInput()$lm.mod)[2],\n        \" with a p-value of\",summary(DateInput()$lm.mod)$coefficients[2,4],\".\")\n  cat(ifelse(summary(DateInput()$lm.mod)$coefficients[2,4]>0.05,\n         \" Statistically this means there is more than a 5% chance that this slope is similar to 0, \n         or we are not confident there is actually a trend.\",\n         paste(\" Statistically this means there is less than a 5% chance that this slope is similar to 0, \n         meaning we are quite confident there is a\",\n         ifelse(coef(DateInput()$lm.mod)[2]>=0,\"positive\",\"negative\"),\n         \"trend.\")))\n  })\n})\n\noutput$fitResults <- renderPrint({\n  if (input$goButton == 0) return(\"\")\n  isolate(\n    cat(\"The adj. r_squared of the line fit is\",summary(DateInput()$lm.mod)$adj.r.squared,\n      \" with an average residual value (RMSE) of\",summary(DateInput()$lm.mod)$sigma,\n      ifelse(input$type==\"rain\",\"mm\",\"degrees C\"),\".\"\n      ,\" In general terms, the closer the adj. r-squared is to 1 means a better fit of the model to the data.\")\n  )\n})\n\noutput$CautionComment <- renderPrint({\n  if (input$goButton == 0) return(\"\")\n  isolate(\n      cat(\"This analysis makes several assumptions, the most important one: that the trend in the data is linear! \n      Also, we are analysing the real data here, more common is to analyse the anomalies\"))\n})\n\n\n  output$testoutput1 <- renderPrint({\n     if (input$goButton == 0) \"\"\n      # this is just a test to see if everything works\n      \"for testing\" \n       as.numeric(as.character(StationOut()$Lat))    \n      #DateInput()$lm.line[1:100]\n   })\n\n\n })\n\n#on.exit({\n  # first delete the tables (see http://stackoverflow.com/questions/23913616/rodbc-sqlsave-table-creation-problems)\n#  try(sqlDrop(db, sqtable=\"main_table\", errors = F), silent=T)\n#  try(sqlDrop(db, sqtable=\"regr_results\", errors = F), silent=T)\n#  try(sqlDrop(db, sqtable=\"regr_stats\", errors = F), silent=T)\n  # write data base tables back\n#  sqlSave(db, df_main, tablename=\"main_table\", rownames=FALSE,safer=F)\n#  sqlSave(db, df_regr_results, tablename=\"regr_results\", rownames=FALSE)\n#  sqlSave(db, df_regr_stats, tablename=\"regr_stats\", rownames=FALSE)\n  \n  # close the connection\n  \n # })\n\n\n",
    "created" : 1414753325522.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "290536870",
    "id" : "365F420F",
    "lastKnownWriteTime" : 1414753749,
    "path" : "~/GitHub/RainfallCS/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}